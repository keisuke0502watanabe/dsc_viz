# -*- coding: utf-8 -*-
"""DSC-tripalmitin-C12TAG-202507-3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wP7App6OEN2DYjYt8qcJxIRF5SOL703c

# OSインストール
"""

import os
os.getcwd()
# パンダス(ファイル読み込みが楽になるやつ)をインストール
import pandas as pd
# ぷろっとりーをインストール
import plotly
from plotly.subplots import make_subplots
import plotly.graph_objs as go
import plotly.io as pio
from plotly import tools
import plotly.express as px

# def MakeInset(dfA, tmin, tmax, offcet, scale):
#   dfa=dfA[(dfA[dfA.columns[0]] <= tmin) & (dfA[dfA.columns[0]] > tmax)] #拡大する範囲を指定
#   dfa[dfA.columns[2]]=dfA[dfA.columns[2]]*scale+offcet #抜き出したグラフを上にずらす
#   dfA=pd.concat([dfa,df])
#   return dfa

def MakeInset(df, tmin, tmax, offset, scale):
  dfA=df.copy()
  dfA=dfA[(dfA[dfA.columns[0]] <= tmax) & (dfA[dfA.columns[0]] > tmin)] #拡大する範囲を指定

  # 抜き出したピークの基準を0に合わせてから *scale + offset
  if abs(dfA[dfA.columns[2]].min()) < abs(dfA[dfA.columns[2]].max()):
    num = dfA[dfA.columns[2]].min()
  else:
    num = dfA[dfA.columns[2]].max()
  dfA.loc[:, ['DSC / uW']] = (dfA.loc[:, ['DSC / uW']] - num)* scale +offset
  return dfA

def MakeInset2(df, Tmin, Tmax, offset, scale):
  dfA=df.copy()
  dfA=dfA[(dfA[dfA.columns[1]] <= Tmax) & (dfA[dfA.columns[1]] > Tmin)] #拡大する範囲を指定
  # 抜き出したピークの基準を0に合わせてから *scale + offset
  if abs(dfA[dfA.columns[2]].min()) < abs(dfA[dfA.columns[2]].max()):
    num = dfA[dfA.columns[2]].min()
  else:
    num = dfA[dfA.columns[2]].max()
  dfA.loc[:, ['DSC / uW']] = (dfA.loc[:, ['DSC / uW']] - num)* scale +offset
  return dfA

def ChangeOffset(df, offset):
  dfA=df.copy()
  dfA.loc[:, ['DSC / uW']] = dfA.loc[:, ['DSC / uW']]+offset
  return dfA

def figAddTrace(fig, df, x, y, names, modes, color):
  fig.add_trace(go.Scatter(x=df[df.columns[x]], y=df[df.columns[y]], name=names, mode=modes, line=dict(color=color)))
  return

def HeatOrCool(df,tmin,tmax,text,num):
  dfA=df.copy()
  dfA.loc[(dfA[dfA.columns[0]] > tmin) & (dfA[dfA.columns[0]] <= tmax), dfA.columns[3]] = text
  dfA.loc[(dfA[dfA.columns[0]] > tmin) & (dfA[dfA.columns[0]] <= tmax), dfA.columns[5]] = num
  return dfA

def LoadDscShimadzuData(file_path,filename):
  # ファイルを開いて行ごとに処理
  with open(file_path, 'r', encoding='utf-16') as file:
      # "Time", "Temp", "DSC"が含まれる行を探す
      index = 0
      for i, line in enumerate(file):
          if "Time\tTemp\tDSC" in line:
              index = i
              break
  # データを読み込む
  #df = pd.read_csv（パス,16ビットの形式を使ってテキストをencordする,生データの上から33行目までスキップ,1行目にヘッダーを登録,生データのスペース区切り）
  df = pd.read_csv(file_path, delimiter='\t', skiprows=index , encoding='utf-16')

  #上で書き換えたデータの0行目（s,℃、μV）を削除
  df =df.drop(0, axis=0)

  #要素の名前書き換え
  df=df.rename(columns={'Time': 'Time / sec','Temp':'Temp. / K', 'DSC':'DSC / uW'})

  #浮動小数点に書き換え（プロットをより細かく）
  df['Temp. / K']=df['Temp. / K'].astype(float)
  df['DSC / uW']=df['DSC / uW'].astype(float)
  df['Time / sec']=df['Time / sec'].astype(float)

  #℃→Kへ変換
  df['Temp. / K']+=273.15

  #新しい要素、Num of Run 追加
  HeatOrCool ="isothermal"
  df['Heat or Cool']=HeatOrCool
  df['filename']=filename
  df['Num of Run']=1

  return df

def dscPlotThAndDsc(df):
  fig_thermalProfile=px.scatter(
      df,x=df.columns[0],y=df.columns[1], color=df.columns[3],color_discrete_sequence=["green", "red", "blue"]
  )
  fig_dscCurve=px.scatter(
      df, x=df.columns[1], y=df.columns[2], color=df.columns[3], color_discrete_sequence=["green", "red", "blue"]
  )
  return fig_dscCurve,fig_thermalProfile

def dscPlotThAndDsc(df):
    # データフレームをコピー
    df_plot = df.copy()

    # サイクル番号を計算（Run番号を3で割った商+1）
    df_plot['Cycle'] = ((df_plot['Num of Run'] - 1) // 3) + 1

    # サイクルごとにオフセットを適用
    offset_multiplier = -40  # オフセットの幅を調整
    df_plot['DSC_offset'] = df_plot[df.columns[2]] + (df_plot['Cycle'] - 1) * offset_multiplier

    # Heat or Coolに基づく色マッピング
    color_map = {
        'heat': 'red',
        'cool': 'blue',
        'isothermal': 'green'
    }

    # 温度プロファイル（時間 vs 温度）- Heat/Cool/Isothermalで色分け
    fig_thermalProfile = px.scatter(
        df_plot,
        x=df.columns[0],  # Time
        y=df.columns[1],  # Temperature
        color=df.columns[3],  # Heat or Cool
        color_discrete_map=color_map,
        symbol='Cycle'  # サイクルで記号を変える
    )
    fig_thermalProfile.update_layout(
        title="Thermal Profile (Color: Heat/Cool, Symbol: Cycle)",
        xaxis_title="Time (sec)",
        yaxis_title="Temperature (K)"
    )

    # DSCカーブ（温度 vs DSC）- Heat/Cool/Isothermalで色分け + サイクルオフセット
    fig_dscCurve = px.scatter(
        df_plot,
        x=df.columns[1],  # Temperature
        y='DSC_offset',   # オフセット適用したDSC値
        color=df.columns[3],  # Heat or Cool
        color_discrete_map=color_map,
        symbol='Cycle'  # サイクルで記号を変える
    )
    fig_dscCurve.update_layout(
        title="DSC Curve (Color: Heat/Cool, Offset: Cycle)",
        xaxis_title="Temperature (K)",
        yaxis_title="DSC (uW) - cycle offset applied"
    )

    return fig_dscCurve, fig_thermalProfile

#ドライブのマウント
from google.colab import drive
drive.mount('/content/drive/')

#ファイルリスト読み込み
file_path='/content/drive/MyDrive/Data/watanabe/DSC-shimadzu/2025/Trilaurin-C12TAG/20250701-trilaurin/3/txt'
#'
list=os.listdir(file_path)
list

"""# データの読み込み"""

#フォルダ内のファイルデータをすべて取得
df={}
i=0
for filename in list:
  file=os.path.join(file_path,filename)
  df[i]=LoadDscShimadzuData(file, filename)
  i+=1

df[0]

#ファイルの選別
# list_i=[0]
list_i=[0]
df_a={}
i=0
for w in list_i:
  fig_dscCurve,fig_thermalProfile=dscPlotThAndDsc(df[w])
  fig_thermalProfile.update_layout(title=list[w])
  fig_thermalProfile.show()
  df_a[i]=df[w]
  i+=1
  # fig_dscCurve.show()

# from re import I
#時間を範囲指定して、coolとheatおよびNum of Runのタグ付け
t={}
t[0]=[0,900,1180,2500]
# t[0]=[0,280,583,1100,1110,1300,1600,2100]
# t[2]=[0,200,500,1900]
# t[0]=[0,710,720,1100,1400,1930,2000,2160,2600]
# t[0]=[0,660,823,1260,1540,2100,2300,2800]
# t[0]=[0,470,668,900,1200,1660,5500,5800,6080,6450,6700,7200,14300,14600,14900,15370,22540,22800,23100,23500,23700,24380,26100,26430,27000]


for i in range(0,len(list_i)):
  print(i)
  for j in range(0,len(t[i])-1,4):
    print(j)
    df_a[i]=HeatOrCool(df_a[i],t[i][j],t[i][j+1],'cool',j+1)
    df_a[i]=HeatOrCool(df_a[i],t[i][j+1],t[i][j+2],'isothermal',j+2)
    df_a[i]=HeatOrCool(df_a[i],t[i][j+2],t[i][j+3],'heat',j+3)
    if j+4<len(t[i]):
      df_a[i]=HeatOrCool(df_a[i],t[i][j+3],t[i][j+4],'isothermal',j+4)
  fig1, fig2 = dscPlotThAndDsc(df_a[i])
  fig1.show()
  fig2.show()

# prompt: fig1とfig2をhtmlとして出力

fig1.write_html("fig1.html")
fig2.write_html("fig2.html")

#熱履歴を横連結
df_b={}
for i in range(len(list_i)):
  df_b[i]=df_a[i].copy()
for i in range(len(list_i)-1):
  df_b[i+1]['Time / sec']=df_b[i+1]['Time / sec']+df_b[i].iloc[-1,0]+1000

df_series={}
df_seriesRun={}
df_c={}
list_color=['green','blue','green','red']
list_hc=['iso','cool','iso','heat']
list_offset=[0,-15,-30,-40, -50,-60,-70]
fig1 = go.Figure()
fig2 = go.Figure()

for j in range(0,len(list_i)):
  for i in range(len(t[j])):
    df_b[j]=MakeInset2(df_b[j], 0, 305, 1, 1)
    df_c[i]=df_b[j][df_b[j][df_b[j].columns[5]] == i]
    figAddTrace(fig1, df_c[i], 0, 1, 'Run='+str(i)+' cool','lines',list_color[i%4])

    if (j!=0)&(i==len(t[j])-1):
      #dfCoolの最終行とdfHeatの最初の行を連結
      dfc=pd.concat([df_b[j-1].tail(1),df_b[j].head(1)])
      # 全てのグラフを以下にまとめて、一つのグラフに表示
      figAddTrace(fig1, dfc, 0, 1, 'iso','lines','green')


fig1.update_layout(
    font =dict(family='Times New Roman', size=24),
    yaxis = dict(
    tickfont = dict(size=24),
    title='<i>T </i>/ K',
    # title='<i>T</i><sub>ref</sub> - <i>T</i><sub>s</sub>  / micro volts',
    #title='d<i>T</i> / <i>\u03BC</i>V',
    showticklabels=True#　熱起電力消去
    ),
    xaxis = dict(
    tickfont = dict(size=36),
    title="<i>time </i>"+ "/ sec ",#　斜体にする
    showticklabels=True

    )
)
fig1.show()

df_c[1]

# df_c={}
list_offset=[0,-10,-60,-110, -50,-60,-70]

fig2 = go.Figure()
for j in range(4):
# for j in range(0,len(list_i)):
  df_b[j]=MakeInset2(df_b[j], 0, 305, 1, 1)
  for i in range(len(t[j])):
    df_c[i]=df_b[j][df_b[j][df_b[j].columns[5]] == i]
    df_c[i]=ChangeOffset(df_c[i], list_offset[j])
    df_c[i]=ChangeOffset(df_c[i], -10*i)
    if ((i==7)or((j==0) & (i==3))):
      dfc=pd.concat([df_c[i-2].tail(1),df_c[i].head(1)])
      figAddTrace(fig2, dfc, 1, 2, 'iso','lines','green')
      figAddTrace(fig2, df_c[i], 1, 2, 'Series - '+str(j)+', Run='+str(i)+' '+list_hc[i%4],'lines',list_color[i%4])
    elif ((j==0 & i==2) or (i==4 or i==6)):
      print('escape')
    else:
      if (j==0 or i >= 4):
        figAddTrace(fig2, df_c[i], 1, 2, 'Series - '+str(j)+', Run='+str(i)+' '+list_hc[i%4],'lines',list_color[i%4])


fig2.update_layout(
    font =dict(family='Times New Roman', size=24),
    yaxis = dict(
    title='<i>exo.</i>  \u2194 <i> endo.</i>',
    showticklabels=False #熱起電力消去
    ),
    xaxis = dict(
    tickfont = dict(size=24),
    title="<i>T </i>"+ "<i>/ K </i>",#斜体にする
    showticklabels=True
    ))
fig2.show()

list_offset=[0,-50,-160,-250, -50,-60,-70]

fig2 = go.Figure()
j=0
df_b[j]=MakeInset2(df_b[j], 0, 305, 1, 1)
for i in range(len(t[j])):
  df_c[i]=df_b[j][df_b[j][df_b[j].columns[5]] == i]
  df_c[i]=ChangeOffset(df_c[i], list_offset[j])
  df_c[i]=ChangeOffset(df_c[i], -10*i)
  # figAddTrace(fig2, df_c[i], 1, 2, 'Series - '+str(j)+', Run='+str(i)+' '+list_hc[i%4],'lines',list_color[i%4])

figAddTrace(fig2, df_c[1], 1, 2, 'Series - '+str(j)+', Run='+str(i)+' '+list_hc[i%4],'lines',list_color[1%4])
figAddTrace(fig2, df_c[3], 1, 2, 'Series - '+str(j)+', Run='+str(i)+' '+list_hc[i%4],'lines',list_color[3%4])

dfc=pd.concat([df_c[1].tail(1),df_c[3].head(1)])
figAddTrace(fig2, dfc, 1, 2, 'iso','lines','green')

#peak
df_heat_peak1=MakeInset2(df_c[1], 155, 250, 30, 20)
figAddTrace(fig2, df_heat_peak1, 1, 2, 'Run=2, heat insert','lines', 'teal')

df_heat_peak1=MakeInset2(df_c[3], 155, 260, -30, 20)
figAddTrace(fig2, df_heat_peak1, 1, 2, 'Run=2, heat insert','lines', 'plum')

j=1
df_b[j]=MakeInset2(df_b[j], 0, 305, 1, 1)
for i in range(len(t[j])):
  df_c[i]=df_b[j][df_b[j][df_b[j].columns[5]] == i]
  df_c[i]=ChangeOffset(df_c[i], list_offset[j])
  df_c[i]=ChangeOffset(df_c[i], -10*i)

figAddTrace(fig2, df_c[5], 1, 2, 'Series - '+str(j)+', Run='+str(i)+' '+list_hc[i%4],'lines',list_color[5%4])
figAddTrace(fig2, df_c[7], 1, 2, 'Series - '+str(j)+', Run='+str(i)+' '+list_hc[i%4],'lines',list_color[7%4])

dfc=pd.concat([df_c[5].tail(1),df_c[7].head(1)])
figAddTrace(fig2, dfc, 1, 2, 'iso','lines','green')

#peak
df_heat_peak1=MakeInset2(df_c[5], 155, 190,-70, 20)
figAddTrace(fig2, df_heat_peak1, 1, 2, 'Run=2, heat insert','lines', 'teal')

df_heat_peak1=MakeInset2(df_c[7], 155, 260, -120, 20)
figAddTrace(fig2, df_heat_peak1, 1, 2, 'Run=2, heat insert','lines', 'plum')


j=2
df_b[j]=MakeInset2(df_b[j], 0, 305, 1, 1)
for i in range(len(t[j])):
  df_c[i]=df_b[j][df_b[j][df_b[j].columns[5]] == i]
  df_c[i]=ChangeOffset(df_c[i], list_offset[j])
  df_c[i]=ChangeOffset(df_c[i], -10*i)

figAddTrace(fig2, df_c[5], 1, 2, 'Series - '+str(j)+', Run='+str(i)+' '+list_hc[i%4],'lines',list_color[5%4])
figAddTrace(fig2, df_c[7], 1, 2, 'Series - '+str(j)+', Run='+str(i)+' '+list_hc[i%4],'lines',list_color[7%4])

dfc=pd.concat([df_c[5].tail(1),df_c[7].head(1)])
figAddTrace(fig2, dfc, 1, 2, 'iso','lines','green')

#peak
df_heat_peak1=MakeInset2(df_c[5], 155, 210,-170, 20)
figAddTrace(fig2, df_heat_peak1, 1, 2, 'Run=2, heat insert','lines', 'teal')

df_heat_peak1=MakeInset2(df_c[7], 155, 260, -240, 20)
figAddTrace(fig2, df_heat_peak1, 1, 2, 'Run=2, heat insert','lines', 'plum')

j=3
df_b[j]=MakeInset2(df_b[j], 0, 305, 1, 1)
for i in range(len(t[j])):
  df_c[i]=df_b[j][df_b[j][df_b[j].columns[5]] == i]
  df_c[i]=ChangeOffset(df_c[i], list_offset[j])
  df_c[i]=ChangeOffset(df_c[i], -10*i)

figAddTrace(fig2, df_c[5], 1, 2, 'Series - '+str(j)+', Run='+str(i)+' '+list_hc[i%4],'lines',list_color[5%4])
figAddTrace(fig2, df_c[7], 1, 2, 'Series - '+str(j)+', Run='+str(i)+' '+list_hc[i%4],'lines',list_color[7%4])

dfc=pd.concat([df_c[5].tail(1),df_c[7].head(1)])
figAddTrace(fig2, dfc, 1, 2, 'iso','lines','green')

#peak
df_heat_peak1=MakeInset2(df_c[5], 155, 210,-250, 20)
figAddTrace(fig2, df_heat_peak1, 1, 2, 'Run=2, heat insert','lines', 'teal')

df_heat_peak1=MakeInset2(df_c[7], 155, 260, -340, 20)
figAddTrace(fig2, df_heat_peak1, 1, 2, 'Run=2, heat insert','lines', 'orange')

fig2.update_layout(
    font =dict(family='Times New Roman', size=24),
    yaxis = dict(
    title='<i>exo.</i>  \u2194 <i> endo.</i>',
    showticklabels=False #熱起電力消去
    ),
    xaxis = dict(
    tickfont = dict(size=24),
    title="<i>T </i>"+ "<i>/ K </i>",#斜体にする
    showticklabels=True
    )
)
fig2.update_layout(
    height=400,  # Specify the height of the graph
    width=600    # Specify the width of the graph
)

fig2.show()



# df_c={}
# list_offset=[0,-15,-30,-40, -50,-60,-70]

fig2 = go.Figure()
for j in range(0,2):
  df_b[j]=MakeInset2(df_b[j], 0, 305, 1, 1)
  for i in range(len(t[j])):
    df_c[i]=df_b[j][df_b[j][df_b[j].columns[5]] == i]
    df_c[i]=ChangeOffset(df_c[i], -100*j)
    df_c[i]=ChangeOffset(df_c[i], -10*i)
    if (i==3):
      dfc=pd.concat([df_c[i-2].tail(1),df_c[i].head(1)])
      figAddTrace(fig2, dfc, 1, 2, 'iso','lines','green')
    else:

      figAddTrace(fig2, df_c[i], 1, 2, 'Series - '+str(j)+', Run='+str(i)+' '+list_hc[i%4],'lines',list_color[i%4])


    # if (j!=0)&(i==len(t[j])-1):
    #   #dfCoolの最終行とdfHeatの最初の行を連結
    #   dfc=pd.concat([df_b[j-1].tail(1),df_b[j].head(1)])
    #   # 全てのグラフを以下にまとめて、一つのグラフに表示
    #   figAddTrace(fig2, dfc, 1, 2, 'iso','lines','green')
fig2.show()

df_c[0]

df_c[0]

#d連結
dfc=pd.concat([df_b[0],df_b[1],df_b[2],df_b[3]])
dfc_2=MakeInset2(dfc, 0, 305, 1, 1)
fig1, fig2 = dscPlotThAndDsc(dfc_2)
fig1.show()
fig2.show()

for i in range(len(dfc.columns)):
  print(i, dfc.columns[i])

fig = go.Figure()
# def MakeInset(df, tmin, tmax, offset, scale):

#冷却
df_cool=MakeInset(df_b[0], t[0][0], t[0][1], 1, 1)
figAddTrace(df_cool, 1, 2, 'Run=1, cool','lines','blue')

#昇温
df_heat=MakeInset(df_b[0], t[0][2], t[0][3], -1, 1)
figAddTrace(df_heat, 1, 2, 'Run=2, heat insert','lines','red')

#dfCoolの最終行とdfHeatの最初の行を連結
dfc=pd.concat([df_cool.tail(1),df_heat.head(1)])
# 全てのグラフを以下にまとめて、一つのグラフに表示
figAddTrace(dfc, 1, 2, 'iso','lines','green')

fig.show()
# for i in range(0,len(list_i)):
#   for j in range(0,len(t[i])-1,4):
#     df_a[i]=HeatOrCool(df_a[i],t[i][j],t[i][j+1],'cool',j+1)
#     df_a[i]=HeatOrCool(df_a[i],t[i][j+1],t[i][j+2],'isothermal',j+2)
#     df_a[i]=HeatOrCool(df_a[i],t[i][j+2],t[i][j+3],'heat',j+3)
#     if j+4<len(t[i]):
#       df_a[i]=HeatOrCool(df_a[i],t[i][j+3],t[i][j+4],'isothermal',j+4)

"""グラフ拡大の改良版"""

# 冷却と昇温を連結
# tminとtmaxの時間で区切る

#冷却とピーク付近の抽出と拡大
fig = go.Figure()
df_cool=MakeInset(df, 0, t1, 1, 1)
figAddTrace(df_cool, 1, 2, 'Run=1, cool','lines','blue')
df_cool_peak=MakeInset2(df_cool, 155, 230, 5, 10)
figAddTrace(df_cool_peak, 1, 2, 'Run=1, cool insert','lines','blue')

#昇温とピーク付近の抽出と拡大
df_heat=MakeInset(df, t2, t3, -1, 1)
figAddTrace(df_heat, 1, 2, 'Run=2, heat','lines','red')
df_heat_peak1=MakeInset2(df_heat, 155, 250, -5, 10)
figAddTrace(df_heat_peak1, 1, 2, 'Run=2, heat insert','lines','red')

#融解ピーク付近の抽出と拡大
# df_melt=MakeInset(df, 5270, 6125, -5, 10)
# figAddTrace(df_melt, 1, 2, 'Run=2, heat insert','lines','red')

#dfCoolの最終行とdfHeatの最初の行を連結
dfc=pd.concat([df_cool.tail(1),df_heat.head(1)])
# 全てのグラフを以下にまとめて、一つのグラフに表示
figAddTrace(dfc, 1, 2, 'iso','lines','green')

#二つ目のグラフ
df2_cool=MakeInset(df2, 0, t4, 30, 1)
figAddTrace(df2_cool, 1, 2, 'p2228 Run=1, cool','lines','blue')
df2_cool_Tg=MakeInset2(df2_cool, 155, 212, 33, 5)
figAddTrace(df2_cool_Tg, 1, 2, 'p2228Run=1, cool insert','lines','blue')

df2_heat=MakeInset(df2, t5, t6, 30, 1)
figAddTrace(df2_heat, 1, 2, 'p2228 Run=1, cool','lines','red')
df2_heat_Tg=MakeInset2(df2_heat, 155, 212, 25, 5)
figAddTrace(df2_heat_Tg, 1, 2, 'p2228Run=1, heat insert','lines','red')

#dfCoolの最終行とdfHeatの最初の行を連結
dfc2=pd.concat([df2_cool.tail(1),df2_heat.head(1)])
# 全てのグラフを以下にまとめて、一つのグラフに表示
figAddTrace(dfc2, 1, 2, 'iso','lines','green')

#レイアウト
fig.update_layout(
    font =dict(family='Times New Roman', size=24),
    yaxis = dict(
    title='<i>exo.</i>  \u2194 <i> endo.</i>',
    showticklabels=False #熱起電力消去
    ),
    xaxis = dict(
    tickfont = dict(size=24),
    title="<i>T </i>"+ "<i>/ K </i>",#斜体にする
    showticklabels=True
    ))

# グラフのx軸の範囲を固定化
fig.update_layout(title=filename,xaxis_range=[140,310])
fig.update_yaxes(
        title_font = {"size": 24},
        title_standoff = 1000)
fig.update_yaxes(
        title_font = {"size": 36},
        tickfont_size = 1,
        title_standoff = 0)

fig.show()

"""# 複数グラフ同時プロット

"""

fig = go.Figure()
fig.add_trace(
    go.Scatter(
            x=df[df.columns[1]], y=df[df.columns[2]],name=file_path
    )
)
fig.add_trace(
    go.Scatter(
            x=df2[df2.columns[1]], y=df2[df2.columns[2]],name=path2
    )
)
"""fig.add_trace(
    go.Scatter(
            x=df3[df3.columns[1]], y=df3[df3.columns[2]],name=path3
    )
)
fig.add_trace(
    go.Scatter(
            x=df4[df4.columns[1]], y=df4[df3.columns[2]],name=path4
    )
)
"""
#レイアウト


fig.update_layout(
    font =dict(family='Times New Roman', size=18),
    yaxis = dict(
    tickfont = dict(size=36),
    title='<i>exo.</i>  \u2194 <i> endo.</i>',
    # title='<i>T</i><sub>ref</sub> - <i>T</i><sub>s</sub>  / micro volts',
    #title='d<i>T</i> / <i>\u03BC</i>V',
    showticklabels=False#　熱起電力消去
    ),
    xaxis = dict(
    tickfont = dict(size=36),
    title="<i>T </i>"+ "<i>/ K </i>",#　斜体にする
    showticklabels=True

    )
    # showticklabels = false,
 #   legend=dict(
  #      title=None,
   # yanchor="top",
    #y=0.22,
    #xanchor="left",
    #x=0.03,
   # ),
    #legend_font_size=19
)
#fig.update_layout(showlegend=False)
#fig.update_xaxes(title_text=r'$\textit{Frequency } \textrm{/ Hz}$')
#fig.update_yaxes(title_text="DQ / MICRO VOLTS")
#fig.update_xaxes(title_text="T / K")

#fig.update_yaxes(title_font=dict(size=20))
#fig.update_xaxes(title_font=dict(size=20))
fig.show()

"""# 一つ一つ独立させてぷろっと

"""

fig=px.scatter(
    df,
    x=df.columns[1],
    y=df.columns[2],
)
fig.show()

fig=px.scatter(
    df2,
    x=df2.columns[1],
    y=df2.columns[2],
)
fig.show()

fig=px.scatter(
    df3,
    x=df3.columns[1],
    y=df3.columns[2],
)
fig.show()

fig=px.scatter(
    df4,
    x=df4.columns[1],
    y=df4.columns[2],
)
fig.show()

"""# グラフ表示

# まとめて一つの画像にプロット
"""

#それぞれのファイルに項目'file'と'df'を追加
df['file'] = 'df'
df2['file'] = 'df2'
df3['file'] = 'df3'
df4['file'] = 'df4'
dfA=pd.concat([df,df2,df3,df4])
fig=px.scatter(
    dfA,
    x=dfA.columns[1],
    y=dfA.columns[2],
    facet_row='file',
)
fig.show()

"""# 融解エンタルピー(KJ/mol)に変換

"""

E=807.64 #エンタルピー（mJ）を代入
S=11.23 #試料量（mg）を代入
M=507.67 #分子量（g/mol）を代入、　p4446→367.40　p4448→395.45　p44412→451.56　p44416→507.67

a= E/1000000  #KJに変換
b= M/(S/1000)  #1/molに変換
c= a*b  #KJ/molを計算
print(c)

"""#積分計算→2023/4/10機械定数？が不明なため使用不可

再読み込みの範囲指定
"""

# 再読み込みする範囲を指定
start_index = 12000
end_index = 15000
# データを指定された範囲で再読み込み
df1 = df.loc[start_index:end_index]
# df1のグラフ表示
fig=px.scatter(
    df1,
    x=df1.columns[1],
    y=df1.columns[2],
)
fig.show()

"""下側上側ベースラインの温度4点、転移温度1点を入力"""

#線形回帰
from sklearn.linear_model import LinearRegression
from scipy import integrate
import numpy as np


Tmin_LT, Tmax_LT=-6.5, 4.7#　下側ベースライン温度域
Tmin_HT, Tmax_HT=34.4, 58.0#　上側ベースライン温度域
Ttrs=23.2 #　転移温度


#新たにdfc1LTを定義
df1_LT=df1[ (Tmin_LT < df1[df1.columns[1]]) & (df1[df1.columns[1]] < Tmax_LT)  ]
#４列目の値がTmin_LT以上かどうか判定#４列目の値がTmax_LT以上かどうか判定
#上側ベースライン
df1_HT = df1[ (Tmin_HT < df1[df1.columns[1]]) & (df1[df1.columns[1]] < Tmax_HT) ]
df_base=pd.concat([df1_LT[::-1], df1_HT[::-1]]) #データ結合
fig = go.Figure()
# for i in range(2):
fig.add_trace(go.Scatter(    x=df1[df.columns[1]], y=df1[df.columns[2]], mode = 'markers'))
fig.add_trace(go.Scatter(    x=df_base[df_base.columns[1]],     y=df_base[df_base.columns[2]] ,   mode = 'markers',   name='data for baseline'))
#線形モデルの重みを学習
lr = LinearRegression()
X1 = df1_LT[[df1_LT.columns[1]]].values         # 説明変数（Numpyの配列）
Y1 = df1_LT[df1_LT.columns[2]].values         # 目的変数（Numpyの配列）
X2 = df1_HT[[df1_HT.columns[1]]].values         # 説明変数（Numpyの配列）
Y2 = df1_HT[df1_HT.columns[2]].values         # 目的変数（Numpyの配列）
#低温側ベースライン
lr.fit(X1, Y1)                         # 線形モデルの重みを学習
print('coefficient = ', lr.coef_[0]) # 説明変数の係数を出力
print('intercept = ', lr.intercept_) # 切片を出力
#fitting出力300
X1=np.append(X1.flatten(), Ttrs) #255Kまで外挿
X1=np.sort(X1)
y1=X1*lr.coef_[0]+lr.intercept_  #
#高温側ベースライン
lr.fit(X2, Y2)                         # 線形モデルの重みを学習
print('coefficient = ', lr.coef_[0]) # 説明変数の係数を出力
print('intercept = ', lr.intercept_) # 切片を出力
#fitting出力
X2=np.append(X2.flatten(), Ttrs) #245Kまで外挿
X2=np.sort(X2)
y2=X2*lr.coef_[0]+lr.intercept_  #
# fig.add_trace(go.Scatter(    x=dfc_base[dfc_base.columns[4]],     y=y,    mode = 'lines',    name="fitting results"  ))
fig.add_trace(go.Scatter(    x=X1.flatten(),     y=y1,    mode = 'lines',    name="fitting results"  ))
fig.add_trace(go.Scatter(    x=X2.flatten(),     y=y2,    mode = 'lines',    name="fitting results"  ))
fig.show()

#ベースライン低温側の積分
x=X1
y=y1

y_integrate_trape_LTbase = integrate.cumtrapz(y, x)  #台形則による数値積分計算
y_integrate_simps_LTbase = integrate.simps(y, x) #シンプソン則による数値積分計算
y_integrate_cymtrap_LTbase=integrate.cumulative_trapezoid(y,x,initial=0) #

print("低温側ベースライン積分")
print('台形則 : {0}'.format(y_integrate_trape_LTbase[-1])) #結果の表示
# print('シンプソン則 : %f'% y_integrate_simps_base)     # 結果の表示
print('シンプソン則 : {0}'.format(y_integrate_simps_LTbase) )   # 結果の表示
print('cumulative : {0}'.format(y_integrate_cymtrap_LTbase[-1]) )   # 結果の表示
error=(y_integrate_trape_LTbase[-1]-y_integrate_simps_LTbase)/y_integrate_trape_LTbase[-1]*100
print('誤差 (台形則 - シンプソン則)/台形則 *100 : %.20lf' % error)
px.line(x=X1,y=y1, markers=True)

#ベースライン高温側の積分
x=X2
y=y2

y_integrate_trape_HTbase = integrate.cumtrapz(y, x)  #台形則による数値積分計算
y_integrate_simps_HTbase = integrate.simps(y, x) #シンプソン則による数値積分計算
y_integrate_cymtrap_HTbase=integrate.cumulative_trapezoid(y,x,initial=0) #

print("高温側ベースライン積分")
print('台形則 : {0}'.format(y_integrate_trape_HTbase[-1])) #結果の表示
# print('シンプソン則 : %f'% y_integrate_simps_base)     # 結果の表示
print('シンプソン則 : {0}'.format(y_integrate_simps_HTbase) )   # 結果の表示
print('cumulative : {0}'.format(y_integrate_cymtrap_HTbase[-1]) )   # 結果の表示
error=(y_integrate_trape_HTbase[-1]-y_integrate_simps_HTbase)/y_integrate_trape_HTbase[-1]*100
print('誤差 (台形則 - シンプソン則)/台形則 *100 : %.20lf' % error)
px.line(x=X2,y=y2, markers=True)

#ベースライン積分値合算
print("ベースライン積分合算")
y_integrate_trape_base=y_integrate_trape_HTbase[-1]+y_integrate_trape_LTbase[-1]
print('台形則 : {0}'.format(y_integrate_trape_base)) #結果の表示
# print('シンプソン則 : %f'% y_integrate_simps_base)     # 結果の表示
y_integrate_simps_base=y_integrate_simps_HTbase+y_integrate_simps_LTbase
print('シンプソン則 : {0}'.format(y_integrate_simps_base) )   # 結果の表示
y_integrate_cymtrap_base=y_integrate_cymtrap_HTbase[-1]+y_integrate_cymtrap_LTbase[-1]
print('cumulative : {0}'.format(y_integrate_cymtrap_base) )   # 結果の表示

#積分区間指定
Tmin, Tmax=Tmin_LT, Tmax_HT
df1_int=df1[     (Tmin < df1[df1.columns[1]])     &     (df1[df1.columns[1]] < Tmax)     ]

#実験値の数値積分
x=df1_int[df1_int.columns[1]]
y=df1_int[df1_int.columns[2]]

z=x.reset_index()
if ((z.iloc[0,1]-z.iloc[1,1]) >0):
  x=df1_int[df1_int.columns[1]][::-1]
  y=df1_int[df1_int.columns[2]][::-1]
# x.reset_index()
# y.reset_index()
y_integrate_trape = integrate.cumtrapz(y, x)  #台形則による数値積分計算
y_integrate_simps = integrate.simps(y, x) #シンプソン則による数値積分計算
y_integrate_cymtrap=integrate.cumulative_trapezoid(y,x,initial=0) #

print("実験値の数値積分")
# print(y_integrate_trape)
print('台形則 : {0}'.format(y_integrate_trape[-1])) #結果の表示
print('シンプソン則 : %f' % y_integrate_simps)     # 結果の表示
# print(y_integrate_cymtrap)
print(y_integrate_cymtrap[-1])

print('積分値 ベースライン差し引き')
a=-y_integrate_trape_base+y_integrate_trape[-1]
b=-y_integrate_simps_base+y_integrate_simps
c=-y_integrate_cymtrap_base+y_integrate_cymtrap[-1]
print('台形則，シンプソン, cumulative')
print(a, b, c)

fig = go.Figure()
# for i in range(2):
fig.add_trace(go.Scatter(    x=x, y=y_integrate_trape, mode = 'markers', name='台形則'))
fig.add_trace(go.Scatter(    x=x, y=y_integrate_cymtrap, name = 'cumulative'))
fig.show()
# fig.add_trace(go.Scatter(    x=dfc_base[dfc_base.columns[4]],     y=dfc_base[dfc_base.columns[3]] ,   mode = 'markers',   name='data for baseline'))

# dfのグラフ表示
"""fig=px.scatter(
    df,
    x="Time",
    y="Temp",
    #color=df.columns[6]
    #size=dfc.columns[8],
    #animation_frame=dfc.columns[8]
    #facet_row='Series'
)"""
# fig.update_layout(height=5000)
#fig.show()
#df_sorted = df.sort_values('Time', ascending=False)
#df_sorted = df.sort_values(['Temp','Time'], ascending=[True,True])#
df2_sorted = df2.sort_values('Temp', ascending=True)
#df_sorted = df.sort_values('Time', ascending=True)
df3 = df2_sorted
df3
#df2
"""fig=px.scatter(
    df3,
    x=df3.columns[0],
    y=df3.columns[1],
    #color=df2.columns[6]
    #size=dfc.columns[8],
    # animation_frame=dfc.columns[8]
    # facet_row='Series'

)
# fig.update_layout(height=5000)
fig.show()"""

