<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSC Data Loader with Thermal Run Detection - Dual Plot</title>
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    <style>
        body {
            font-family: 'Times New Roman', serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .file-input {
            margin: 20px 0;
            padding: 20px;
            border: 2px dashed #ccc;
            border-radius: 5px;
            text-align: center;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
        }
        .success { background-color: #d4edda; color: #155724; }
        .error { background-color: #f8d7da; color: #721c24; }
        .section {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #007bff;
        }
        .section h3 {
            margin-top: 0;
            color: #007bff;
        }
        .section-content {
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            margin-top: 10px;
        }
        .data-table th, .data-table td {
            border: 1px solid #ddd;
            padding: 4px;
            text-align: left;
        }
        .data-table th {
            background-color: #f2f2f2;
        }
        .data-display {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            max-height: 300px;
            overflow-y: auto;
        }
        .tabs {
            display: flex;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            background-color: #e9ecef;
            border: 1px solid #ccc;
            cursor: pointer;
            margin-right: 5px;
        }
        .tab.active {
            background-color: #007bff;
            color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .thermal-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        .thermal-table th, .thermal-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .thermal-table th {
            background-color: #f2f2f2;
        }
        .plot-container {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .plot-controls {
            margin: 10px 0;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 5px;
        }
        .plot-controls label {
            margin-right: 10px;
        }
        .plot-controls input, .plot-controls select {
            margin-right: 15px;
        }
        .plot-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .plot-item {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            background-color: white;
        }
        .plot-item h4 {
            margin-top: 0;
            text-align: center;
            color: #007bff;
        }
        .run-settings {
            margin: 10px 0;
            padding: 10px;
            background-color: #d1ecf1;
            border-radius: 5px;
            border: 1px solid #bee5eb;
        }
        .run-settings h5 {
            margin-top: 0;
            color: #0c5460;
        }
        .run-offset-input {
            display: inline-block;
            margin: 5px;
        }
        .run-offset-input label {
            display: block;
            font-size: 12px;
            margin-bottom: 2px;
        }
        .run-offset-input input {
            width: 60px;
            padding: 2px;
        }
        .run-time-settings {
            margin: 10px 0;
            padding: 10px;
            background-color: #fff3cd;
            border-radius: 5px;
            border: 1px solid #ffeaa7;
        }
        .run-time-settings h5 {
            margin-top: 0;
            color: #856404;
        }
        .run-time-input {
            display: inline-block;
            margin: 5px;
        }
        .run-time-input label {
            display: block;
            font-size: 12px;
            margin-bottom: 2px;
        }
        .run-time-input input {
            width: 80px;
            padding: 2px;
        }
        .run-time-row {
            display: flex;
            align-items: center;
            margin: 5px 0;
            padding: 5px;
            background-color: #f8f9fa;
            border-radius: 3px;
        }
        .run-time-row label {
            margin-right: 10px;
            min-width: 80px;
        }
        .run-controls {
            margin: 10px 0;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 5px;
        }
        .run-controls button {
            margin: 5px;
            padding: 5px 10px;
            font-size: 12px;
        }
        .legend-controls {
            margin: 10px 0;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 5px;
        }
        .legend-controls h5 {
            margin-top: 0;
            color: #495057;
        }
        .legend-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .legend-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            background-color: #f8f9fa;
            border-radius: 3px;
        }
        .legend-option label {
            margin: 0;
            font-size: 12px;
        }
        .legend-option select {
            padding: 2px 5px;
            font-size: 12px;
        }
        .axis-controls {
            margin: 10px 0;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 5px;
        }
        .axis-controls h5 {
            margin-top: 0;
            color: #495057;
        }
        .axis-options {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        .axis-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px;
            background-color: #f8f9fa;
            border-radius: 3px;
        }
        .axis-option label {
            margin: 0;
            font-size: 12px;
            min-width: 100px;
        }
        .axis-option input, .axis-option select {
            padding: 2px 5px;
            font-size: 12px;
        }
        .axis-option input[type="text"] {
            width: 120px;
        }
        .axis-option input[type="number"] {
            width: 60px;
        }
        .add-run-btn {
            background-color: #28a745;
        }
        .add-run-btn:hover {
            background-color: #218838;
        }
        .delete-run-btn {
            background-color: #dc3545;
        }
        .delete-run-btn:hover {
            background-color: #c82333;
        }
        .run-plot-section {
            margin: 10px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }
        .run-plot-section h5 {
            margin-top: 0;
            color: #495057;
        }
        .run-info {
            margin: 10px 0;
            padding: 10px;
            background-color: #f8d7da;
            border-radius: 5px;
            border: 1px solid #f5c6cb;
        }
        .run-info h5 {
            margin-top: 0;
            color: #721c24;
        }
        .run-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        .run-table th, .run-table td {
            border: 1px solid #ddd;
            padding: 4px;
            text-align: left;
        }
        .run-table th {
            background-color: #f2f2f2;
        }
        .thermal-program {
            margin: 10px 0;
            padding: 10px;
            background-color: #d4edda;
            border-radius: 5px;
            border: 1px solid #c3e6cb;
        }
        .thermal-program h5 {
            margin-top: 0;
            color: #155724;
        }
        .program-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        .program-table th, .program-table td {
            border: 1px solid #ddd;
            padding: 4px;
            text-align: left;
        }
        .program-table th {
            background-color: #f2f2f2;
        }
        .dsc-subplot-container {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            background-color: white;
        }
        .dsc-subplot-container h4 {
            margin-top: 0;
            text-align: center;
            color: #007bff;
        }
        @media (max-width: 1200px) {
            .plot-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DSC Data Loader with Thermal Run Detection - Dual Plot</h1>
        
        <div class="file-input">
            <h3>データファイルをアップロード</h3>
            <input type="file" id="fileInput" accept=".txt" multiple>
            <p>Shimadzu DSCのテキストファイル（.txt）を選択してください</p>
            <button onclick="loadData()">データ読み込み</button>
        </div>

        <div id="status" class="status" style="display: none;"></div>

        <div id="tabs" class="tabs" style="display: none;">
            <div class="tab active" onclick="showTab('experimental')">実験条件</div>
            <div class="tab" onclick="showTab('thermal')">熱履歴</div>
            <div class="tab" onclick="showTab('data')">データ</div>
            <div class="tab" onclick="showTab('runs')">Run情報</div>
            <div class="tab" onclick="showTab('plot')">プロット</div>
        </div>

        <div id="experimentalSection" class="tab-content active">
            <div class="section">
                <h3>実験条件</h3>
                <div id="experimentalContent" class="section-content"></div>
            </div>
        </div>

        <div id="thermalSection" class="tab-content">
            <div class="section">
                <h3>熱履歴</h3>
                <div id="thermalContent"></div>
            </div>
        </div>

        <div id="dataSection" class="tab-content">
            <div class="section">
                <h3>データ</h3>
                <div id="dataContent" class="section-content"></div>
            </div>
        </div>

        <div id="runsSection" class="tab-content">
            <div class="thermal-program">
                <h5>熱プログラム</h5>
                <div id="thermalProgram"></div>
            </div>
            <div class="run-time-settings">
                <h5>Run時間設定（マニュアル調整）</h5>
                <div class="run-controls">
                    <button class="add-run-btn" onclick="addNewRun()">Runを追加</button>
                    <button class="delete-run-btn" onclick="deleteLastRun()">最後のRunを削除</button>
                    <button onclick="saveRunSettings()" style="background-color: #17a2b8;">Run設定を保存</button>
                    <button onclick="loadRunSettings()" style="background-color: #6c757d;">Run設定を読み込み</button>
                    <button onclick="exportRunSettings()" style="background-color: #28a745;">設定をエクスポート</button>
                    <button onclick="importRunSettings()" style="background-color: #ffc107; color: #000;">設定をインポート</button>
                </div>
                <div id="runTimeInputs">
                    <!-- 動的に生成される -->
                </div>
                <button onclick="applyManualRunTimes()">Run時間を適用</button>
                <button onclick="resetToAutoRunTimes()">自動検出に戻す</button>
            </div>
            <div class="run-plot-section">
                <h5>熱履歴プロファイル（Run情報表示）</h5>
                <div id="runThermalPlot"></div>
            </div>
            <div class="run-info">
                <h5>Run情報</h5>
                <div id="runInfo"></div>
            </div>
        </div>

        <div id="plotSection" class="tab-content">
            <div class="plot-container">
                <h3>プロット表示</h3>
                <div class="plot-controls">
                    <label>表示タイプ:</label>
                    <select id="plotType">
                        <option value="scatter">散布図</option>
                        <option value="line">線グラフ</option>
                        <option value="both">散布図+線</option>
                    </select>
                    <label>温度範囲:</label>
                    <input type="number" id="tempMin" placeholder="最小温度" value="">
                    <input type="number" id="tempMax" placeholder="最大温度" value="">
                    <label>DSC範囲:</label>
                    <input type="number" id="dscMin" placeholder="最小DSC" value="">
                    <input type="number" id="dscMax" placeholder="最大DSC" value="">
                    <label>時間範囲:</label>
                    <input type="number" id="timeMin" placeholder="最小時間" value="">
                    <input type="number" id="timeMax" placeholder="最大時間" value="">
                    <button onclick="updatePlot()">プロット更新</button>
                    <button onclick="resetPlot()">リセット</button>
                </div>
                
                <div class="legend-controls">
                    <h5>凡例設定</h5>
                    <div class="legend-options">
                        <div class="legend-option">
                            <label>熱履歴プロファイル凡例:</label>
                            <input type="checkbox" id="thermalLegendShow" checked>
                            <label for="thermalLegendShow">表示</label>
                            <select id="thermalLegendPosition">
                                <option value="top-left">左上</option>
                                <option value="top-right">右上</option>
                                <option value="bottom-left">左下</option>
                                <option value="bottom-right">右下</option>
                                <option value="top-center">上中央</option>
                                <option value="bottom-center">下中央</option>
                            </select>
                        </div>
                        <div class="legend-option">
                            <label>DSC曲線凡例:</label>
                            <input type="checkbox" id="dscLegendShow" checked>
                            <label for="dscLegendShow">表示</label>
                            <select id="dscLegendPosition">
                                <option value="top-left">左上</option>
                                <option value="top-right">右上</option>
                                <option value="bottom-left">左下</option>
                                <option value="bottom-right">右下</option>
                                <option value="top-center">上中央</option>
                                <option value="bottom-center">下中央</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="axis-controls">
                    <h5>軸設定</h5>
                    <div class="axis-options">
                        <div class="axis-option">
                            <label>X軸タイトル:</label>
                            <input type="text" id="xAxisTitle" value="Time (sec)" placeholder="X軸タイトル">
                        </div>
                        <div class="axis-option">
                            <label>Y軸タイトル:</label>
                            <input type="text" id="yAxisTitle" value="Temperature (K)" placeholder="Y軸タイトル">
                        </div>
                        <div class="axis-option">
                            <label>DSC Y軸タイトル:</label>
                            <input type="text" id="dscYAxisTitle" value="DSC (uW)" placeholder="DSC Y軸タイトル">
                        </div>
                        <div class="axis-option">
                            <label>フォントファミリー:</label>
                            <select id="fontFamily">
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Arial">Arial</option>
                                <option value="Helvetica">Helvetica</option>
                                <option value="Courier New">Courier New</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Verdana">Verdana</option>
                            </select>
                        </div>
                        <div class="axis-option">
                            <label>フォントサイズ:</label>
                            <input type="number" id="fontSize" value="14" min="8" max="24" step="1">
                        </div>
                        <div class="axis-option">
                            <label>軸ラベルサイズ:</label>
                            <input type="number" id="axisLabelSize" value="12" min="8" max="20" step="1">
                        </div>
                    </div>
                </div>
                
                <div class="run-settings">
                    <h5>Runオフセット設定</h5>
                    <div id="runOffsetInputs">
                        <!-- 動的に生成される -->
                    </div>
                </div>
                
                <div class="plot-grid">
                    <div class="plot-item">
                        <h4>熱履歴プロファイル (全Run同時表示)</h4>
                        <div id="thermalPlot"></div>
                    </div>
                    <div class="dsc-subplot-container">
                        <h4>DSC曲線 (オフセットなし vs オフセットあり)</h4>
                        <div id="dscPlot"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="dataDisplay" class="data-display" style="display: none;">
            <h3>読み込み済みデータ</h3>
            <div id="dataTable"></div>
        </div>
    </div>

    <script>
        // グローバル変数
        let loadedData = {};
        let fileSections = {};
        let processedData = {};
        let runData = {};
        let thermalPrograms = {};
        let originalRunData = {}; // 自動検出されたRunデータのバックアップ
        let currentFilenames = []; // 現在のファイル名リスト

        // ステータス表示関数
        function showStatus(message, type = 'success') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            setTimeout(() => {
                status.style.display = 'none';
            }, 5000);
        }

        // タブ表示関数
        function showTab(tabName) {
            // すべてのタブを非アクティブにする
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // 選択されたタブをアクティブにする
            event.target.classList.add('active');
            document.getElementById(tabName + 'Section').classList.add('active');
            
            // プロットタブが選択された場合、プロットを更新
            if (tabName === 'plot') {
                updatePlot();
            }
            // Run情報タブが選択された場合、Run用のプロットを更新
            if (tabName === 'runs') {
                updateRunThermalPlot();
            }
        }

        // ファイル読み込み関数
        function loadData() {
            const fileInput = document.getElementById('fileInput');
            const files = fileInput.files;
            
            if (files.length === 0) {
                showStatus('ファイルを選択してください', 'error');
                return;
            }

            loadedData = {};
            fileSections = {};
            processedData = {};
            runData = {};
            thermalPrograms = {};
            currentFilenames = [];
            let loadedCount = 0;

            Array.from(files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const text = e.target.result;
                        console.log(`Loading file ${index + 1}: ${file.name}`);
                        
                        // ファイルを3つのセクションに分割
                        const sections = parseFileSections(text, file.name);
                        fileSections[index] = sections;
                        
                        // データ部分をパース
                        const data = parseShimadzuData(text, file.name);
                        loadedData[index] = data;
                        currentFilenames[index] = file.name;
                        loadedCount++;
                        
                        if (loadedCount === files.length) {
                            showStatus(`${loadedCount}個のファイルを読み込みました`);
                            // 熱プログラムを解析
                            parseThermalPrograms();
                            // Runを検出・分類
                            detectRunsFromThermalProgram();
                            displaySections();
                            displayData();
                            displayRunInfo();
                            document.getElementById('tabs').style.display = 'flex';
                            
                            // 範囲を自動設定
                            setAutoRanges();
                        }
                    } catch (error) {
                        console.error(`Error loading file ${file.name}:`, error);
                        showStatus(`ファイル ${file.name} の読み込みに失敗しました: ${error.message}`, 'error');
                    }
                };
                
                reader.readAsText(file, 'UTF-16');
            });
        }

        // 熱プログラムを解析
        function parseThermalPrograms() {
            thermalPrograms = {};
            
            Object.keys(fileSections).forEach(fileKey => {
                const thermalSection = fileSections[fileKey].thermal;
                const program = [];
                
                // 熱プログラムのテーブルを探す
                let inTable = false;
                for (let i = 0; i < thermalSection.length; i++) {
                    const line = thermalSection[i];
                    
                    // テーブルヘッダーを検出
                    if (line.includes('加熱速度') && line.includes('ホールド温度') && line.includes('ホールド時間')) {
                        inTable = true;
                        continue;
                    }
                    
                    // テーブルデータを解析
                    if (inTable && line.trim() !== '') {
                        const parts = line.split('\t');
                        if (parts.length >= 5) {
                            const heatingRate = parseFloat(parts[0]);
                            const holdTemp = parseFloat(parts[1]);
                            const holdTime = parseFloat(parts[2]);
                            const ln2 = parts[3].trim();
                            const gas = parts[4].trim();
                            
                            if (!isNaN(heatingRate) && !isNaN(holdTemp) && !isNaN(holdTime)) {
                                program.push({
                                    heatingRate: heatingRate,
                                    holdTemp: holdTemp,
                                    holdTime: holdTime,
                                    ln2: ln2,
                                    gas: gas
                                });
                            }
                        }
                    }
                }
                
                thermalPrograms[fileKey] = program;
                console.log(`File ${parseInt(fileKey) + 1} thermal program:`, program);
            });
        }

        // 熱プログラムからRunを検出・分類
        function detectRunsFromThermalProgram() {
            runData = {};
            
            Object.keys(loadedData).forEach(fileKey => {
                const data = loadedData[fileKey];
                const program = thermalPrograms[fileKey];
                const runs = [];
                
                if (program.length === 0) {
                    // 熱プログラムが見つからない場合は従来の方法を使用
                    runs.push({
                        runNumber: 1,
                        startTime: data[0].time,
                        endTime: data[data.length-1].time,
                        data: data,
                        heatingRate: 0,
                        holdTemp: 0,
                        holdTime: 0
                    });
                } else {
                    // 熱プログラムに基づいてRunを分割
                    let currentTime = data[0].time;
                    let runNumber = 1;
                    
                    for (let i = 0; i < program.length; i++) {
                        const step = program[i];
                        const stepDuration = step.holdTime * 60; // 分を秒に変換
                        const endTime = currentTime + stepDuration;
                        
                        // このステップに対応するデータを抽出
                        const stepData = data.filter(point => 
                            point.time >= currentTime && point.time < endTime
                        );
                        
                        if (stepData.length > 0) {
                            runs.push({
                                runNumber: runNumber,
                                startTime: currentTime,
                                endTime: endTime,
                                data: stepData,
                                heatingRate: step.heatingRate,
                                holdTemp: step.holdTemp,
                                holdTime: step.holdTime,
                                ln2: step.ln2,
                                gas: step.gas
                            });
                        }
                        
                        currentTime = endTime;
                        runNumber++;
                    }
                }
                
                runData[fileKey] = runs;
            });
            
            // 自動検出されたRunデータをバックアップ
            originalRunData = JSON.parse(JSON.stringify(runData));
            
            console.log('Detected runs from thermal program:', runData);
        }

        // Run情報を表示
        function displayRunInfo() {
            const thermalProgram = document.getElementById('thermalProgram');
            const runInfo = document.getElementById('runInfo');
            let programHtml = '';
            let runHtml = '';
            
            Object.keys(thermalPrograms).forEach(fileKey => {
                const program = thermalPrograms[fileKey];
                programHtml += `<h6>File ${parseInt(fileKey) + 1} - 熱プログラム</h6>`;
                
                if (program.length > 0) {
                    programHtml += '<table class="program-table">';
                    programHtml += '<thead><tr><th>ステップ</th><th>加熱速度</th><th>ホールド温度</th><th>ホールド時間</th><th>LN2</th><th>ガス</th></tr></thead>';
                    programHtml += '<tbody>';
                    
                    program.forEach((step, index) => {
                        programHtml += `<tr>
                            <td>${index + 1}</td>
                            <td>${step.heatingRate} °C/min</td>
                            <td>${step.holdTemp} °C</td>
                            <td>${step.holdTime} min</td>
                            <td>${step.ln2}</td>
                            <td>${step.gas}</td>
                        </tr>`;
                    });
                    
                    programHtml += '</tbody></table><br>';
                } else {
                    programHtml += '<p>熱プログラムが見つかりませんでした。</p><br>';
                }
            });
            
            Object.keys(runData).forEach(fileKey => {
                const runs = runData[fileKey];
                runHtml += `<h6>File ${parseInt(fileKey) + 1} - Run情報</h6>`;
                runHtml += '<table class="run-table">';
                runHtml += '<thead><tr><th>Run</th><th>開始時間</th><th>終了時間</th><th>データ点数</th><th>加熱速度</th><th>ホールド温度</th><th>ホールド時間</th></tr></thead>';
                runHtml += '<tbody>';
                
                runs.forEach(run => {
                    runHtml += `<tr>
                        <td>Run-${run.runNumber}</td>
                        <td>${run.startTime.toFixed(1)}</td>
                        <td>${run.endTime.toFixed(1)}</td>
                        <td>${run.data.length}</td>
                        <td>${run.heatingRate} °C/min</td>
                        <td>${run.holdTemp} °C</td>
                        <td>${run.holdTime} min</td>
                    </tr>`;
                });
                
                runHtml += '</tbody></table><br>';
            });
            
            thermalProgram.innerHTML = programHtml;
            runInfo.innerHTML = runHtml;
            
            // Runオフセット設定を生成
            generateRunOffsetInputs();
            // Run時間設定を生成
            generateRunTimeInputs();
            // Run用のプロットを更新
            updateRunThermalPlot();
        }

        // Runオフセット設定を生成
        function generateRunOffsetInputs() {
            const runOffsetInputs = document.getElementById('runOffsetInputs');
            let html = '';
            
            Object.keys(runData).forEach(fileKey => {
                const runs = runData[fileKey];
                html += `<h6>File ${parseInt(fileKey) + 1}</h6>`;
                
                runs.forEach(run => {
                    html += `
                        <div class="run-offset-input">
                            <label>Run-${run.runNumber}:</label>
                            <input type="number" id="run_${fileKey}_${run.runNumber}_offset" 
                                   value="${(run.runNumber - 1) * -40}" step="10">
                        </div>
                    `;
                });
                html += '<br>';
            });
            
            runOffsetInputs.innerHTML = html;
        }

        // Run時間設定を生成
        function generateRunTimeInputs() {
            const runTimeInputs = document.getElementById('runTimeInputs');
            let html = '';
            
            Object.keys(runData).forEach(fileKey => {
                const runs = runData[fileKey];
                html += `<h6>File ${parseInt(fileKey) + 1}</h6>`;
                
                runs.forEach((run, index) => {
                    html += `
                        <div class="run-time-row">
                            <label>Run-${run.runNumber}:</label>
                            <input type="number" id="run_${fileKey}_${run.runNumber}_start" 
                                   value="${run.startTime.toFixed(1)}" step="0.1" placeholder="開始時間">
                            <span>～</span>
                            <input type="number" id="run_${fileKey}_${run.runNumber}_end" 
                                   value="${run.endTime.toFixed(1)}" step="0.1" placeholder="終了時間">
                            <button class="delete-run-btn" onclick="deleteSpecificRun('${fileKey}', ${run.runNumber})" 
                                    style="margin-left: 10px; padding: 2px 6px; font-size: 10px;">削除</button>
                        </div>
                    `;
                });
                html += '<br>';
            });
            
            runTimeInputs.innerHTML = html;
        }

        // マニュアルRun時間を適用
        function applyManualRunTimes() {
            const newRunData = {};
            
            Object.keys(runData).forEach(fileKey => {
                const runs = runData[fileKey];
                const newRuns = [];
                const data = loadedData[fileKey];
                
                runs.forEach(run => {
                    const startTimeInput = document.getElementById(`run_${fileKey}_${run.runNumber}_start`);
                    const endTimeInput = document.getElementById(`run_${fileKey}_${run.runNumber}_end`);
                    
                    if (startTimeInput && endTimeInput) {
                        const newStartTime = parseFloat(startTimeInput.value);
                        const newEndTime = parseFloat(endTimeInput.value);
                        
                        if (!isNaN(newStartTime) && !isNaN(newEndTime) && newStartTime < newEndTime) {
                            // 新しい時間範囲でデータを抽出
                            const newData = data.filter(point => 
                                point.time >= newStartTime && point.time < newEndTime
                            );
                            
                            if (newData.length > 0) {
                                newRuns.push({
                                    ...run,
                                    startTime: newStartTime,
                                    endTime: newEndTime,
                                    data: newData
                                });
                            }
                        } else {
                            // 無効な値の場合は元のRunを保持
                            newRuns.push(run);
                        }
                    } else {
                        newRuns.push(run);
                    }
                });
                
                newRunData[fileKey] = newRuns;
            });
            
            runData = newRunData;
            displayRunInfo();
            updateRunThermalPlot();
            showStatus('Run時間を手動設定で更新しました');
        }

        // 自動検出に戻す
        function resetToAutoRunTimes() {
            runData = JSON.parse(JSON.stringify(originalRunData));
            generateRunTimeInputs();
            displayRunInfo();
            updateRunThermalPlot();
            showStatus('Run時間を自動検出に戻しました');
        }

        // 新しいRunを追加
        function addNewRun() {
            if (Object.keys(runData).length === 0) {
                showStatus('データを先に読み込んでください', 'error');
                return;
            }

            Object.keys(runData).forEach(fileKey => {
                const runs = runData[fileKey];
                const data = loadedData[fileKey];
                
                if (runs.length === 0) return;
                
                // 最後のRunの終了時間を取得
                const lastRun = runs[runs.length - 1];
                const newRunNumber = runs.length + 1;
                
                // 新しいRunの時間範囲を設定（最後のRunの終了時間から開始）
                const newStartTime = lastRun.endTime;
                const newEndTime = data[data.length - 1].time; // データの最後まで
                
                // 新しいRunのデータを抽出
                const newData = data.filter(point => 
                    point.time >= newStartTime && point.time <= newEndTime
                );
                
                if (newData.length > 0) {
                    const newRun = {
                        runNumber: newRunNumber,
                        startTime: newStartTime,
                        endTime: newEndTime,
                        data: newData,
                        heatingRate: 0,
                        holdTemp: 0,
                        holdTime: 0,
                        ln2: 'N/A',
                        gas: 'N/A'
                    };
                    
                    runs.push(newRun);
                }
            });
            
            generateRunTimeInputs();
            displayRunInfo();
            updateRunThermalPlot();
            showStatus('新しいRunを追加しました');
        }

        // 最後のRunを削除
        function deleteLastRun() {
            if (Object.keys(runData).length === 0) {
                showStatus('削除するRunがありません', 'error');
                return;
            }

            let hasDeleted = false;
            Object.keys(runData).forEach(fileKey => {
                const runs = runData[fileKey];
                if (runs.length > 1) { // 最低1つのRunは残す
                    runs.pop();
                    hasDeleted = true;
                }
            });
            
            if (hasDeleted) {
                generateRunTimeInputs();
                displayRunInfo();
                updateRunThermalPlot();
                showStatus('最後のRunを削除しました');
            } else {
                showStatus('最低1つのRunが必要です', 'error');
            }
        }

        // 特定のRunを削除
        function deleteSpecificRun(fileKey, runNumber) {
            const runs = runData[fileKey];
            if (runs.length <= 1) {
                showStatus('最低1つのRunが必要です', 'error');
                return;
            }
            
            const runIndex = runs.findIndex(run => run.runNumber === runNumber);
            if (runIndex !== -1) {
                runs.splice(runIndex, 1);
                
                // Run番号を再振り分け
                runs.forEach((run, index) => {
                    run.runNumber = index + 1;
                });
                
                generateRunTimeInputs();
                displayRunInfo();
                updateRunThermalPlot();
                showStatus(`Run-${runNumber}を削除しました`);
            }
        }

        // ファイルを3つのセクションに分割する関数
        function parseFileSections(text, filename) {
            const lines = text.split('\n');
            const sections = {
                experimental: [],
                thermal: [],
                data: []
            };
            
            let currentSection = 'experimental';
            let dataStartIndex = -1;
            let thermalStartIndex = -1;
            
            // 熱履歴の開始行を探す（加熱速度、ホールド温度、ホールド時間、LN2、ガス）
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].toLowerCase();
                if (line.includes('加熱速度') || line.includes('ホールド温度') || 
                    line.includes('ホールド時間') || line.includes('ln2') || 
                    line.includes('ガス')) {
                    thermalStartIndex = i;
                    console.log('Thermal history header found at line:', i + 1);
                    break;
                }
            }
            
            // データヘッダーを探す
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].includes("Time\tTemp\tDSC")) {
                    dataStartIndex = i;
                    break;
                }
            }
            
            // より柔軟な検索
            if (dataStartIndex === -1) {
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].toLowerCase();
                    if (line.includes('time') && line.includes('temp') && line.includes('dsc')) {
                        dataStartIndex = i;
                        break;
                    }
                }
            }
            
            // セクション分け
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                if (i === dataStartIndex) {
                    currentSection = 'data';
                    sections.data.push(line); // ヘッダー行も含める
                } else if (i < dataStartIndex) {
                    // 熱履歴の開始行以降は熱履歴
                    if (thermalStartIndex !== -1 && i >= thermalStartIndex) {
                        currentSection = 'thermal';
                    } else {
                        currentSection = 'experimental';
                    }
                    sections[currentSection].push(line);
                } else {
                    // データヘッダーより後はデータ
                    sections.data.push(line);
                }
            }
            
            return sections;
        }

        // セクション表示関数
        function displaySections() {
            const experimentalContent = document.getElementById('experimentalContent');
            const thermalContent = document.getElementById('thermalContent');
            const dataContent = document.getElementById('dataContent');
            
            let experimentalText = '';
            let thermalText = '';
            let dataText = '';
            
            Object.keys(fileSections).forEach(key => {
                const sections = fileSections[key];
                experimentalText += `=== File ${parseInt(key) + 1} ===\n`;
                experimentalText += sections.experimental.join('\n') + '\n\n';
                
                thermalText += `=== File ${parseInt(key) + 1} ===\n`;
                thermalText += sections.thermal.join('\n') + '\n\n';
                
                dataText += `=== File ${parseInt(key) + 1} ===\n`;
                dataText += sections.data.slice(0, 20).join('\n') + '\n';
                if (sections.data.length > 20) {
                    dataText += `... (${sections.data.length - 20} more lines)\n`;
                }
                dataText += '\n';
            });
            
            experimentalContent.textContent = experimentalText;
            
            // 熱履歴をテーブル形式で表示
            displayThermalHistory(thermalText);
            
            dataContent.textContent = dataText;
        }

        // 熱履歴をテーブル形式で表示
        function displayThermalHistory(thermalText) {
            const thermalContent = document.getElementById('thermalContent');
            
            // 熱履歴データを解析
            const thermalData = parseThermalHistory(thermalText);
            
            let html = '<table class="thermal-table">';
            html += '<thead><tr><th>ファイル</th><th>加熱速度</th><th>ホールド温度</th><th>ホールド時間</th><th>LN2</th><th>ガス</th></tr></thead>';
            html += '<tbody>';
            
            thermalData.forEach((data, index) => {
                html += `<tr>
                    <td>File ${index + 1}</td>
                    <td>${data.heatingRate || 'N/A'}</td>
                    <td>${data.holdTemp || 'N/A'}</td>
                    <td>${data.holdTime || 'N/A'}</td>
                    <td>${data.ln2 || 'N/A'}</td>
                    <td>${data.gas || 'N/A'}</td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            
            // 生データも表示
            html += '<h4>生データ:</h4>';
            html += '<div class="section-content">' + thermalText + '</div>';
            
            thermalContent.innerHTML = html;
        }

        // 熱履歴データを解析
        function parseThermalHistory(thermalText) {
            const files = thermalText.split('=== File');
            const thermalData = [];
            
            files.forEach((fileData, index) => {
                if (fileData.trim() === '') return;
                
                const lines = fileData.split('\n');
                const data = {
                    heatingRate: '',
                    holdTemp: '',
                    holdTime: '',
                    ln2: '',
                    gas: ''
                };
                
                lines.forEach(line => {
                    const lowerLine = line.toLowerCase();
                    if (lowerLine.includes('加熱速度')) {
                        data.heatingRate = line.split(':')[1]?.trim() || line.split('=')[1]?.trim() || 'Found';
                    }
                    if (lowerLine.includes('ホールド温度')) {
                        data.holdTemp = line.split(':')[1]?.trim() || line.split('=')[1]?.trim() || 'Found';
                    }
                    if (lowerLine.includes('ホールド時間')) {
                        data.holdTime = line.split(':')[1]?.trim() || line.split('=')[1]?.trim() || 'Found';
                    }
                    if (lowerLine.includes('ln2')) {
                        data.ln2 = line.split(':')[1]?.trim() || line.split('=')[1]?.trim() || 'Found';
                    }
                    if (lowerLine.includes('ガス')) {
                        data.gas = line.split(':')[1]?.trim() || line.split('=')[1]?.trim() || 'Found';
                    }
                });
                
                thermalData.push(data);
            });
            
            return thermalData;
        }

        // Shimadzu DSCデータのパース関数
        function parseShimadzuData(text, filename) {
            const lines = text.split('\n');
            let dataStartIndex = -1;
            
            // "Time\tTemp\tDSC"を含む行を探す
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].includes("Time\tTemp\tDSC")) {
                    dataStartIndex = i;
                    break;
                }
            }
            
            // より柔軟な検索
            if (dataStartIndex === -1) {
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].toLowerCase();
                    if (line.includes('time') && line.includes('temp') && line.includes('dsc')) {
                        dataStartIndex = i;
                        break;
                    }
                }
            }
            
            if (dataStartIndex === -1) {
                throw new Error('データヘッダーが見つかりません。ファイル形式を確認してください。');
            }

            // データを抽出（ヘッダーの次の行から開始）
            const dataLines = lines.slice(dataStartIndex + 1).filter(line => line.trim());
            const data = [];
            
            dataLines.forEach((line, lineIndex) => {
                const parts = line.split('\t');
                if (parts.length >= 3) {
                    const time = parseFloat(parts[0]);
                    const temp = parseFloat(parts[1]) + 273.15; // ℃→K変換
                    const dsc = parseFloat(parts[2]);
                    
                    if (!isNaN(time) && !isNaN(temp) && !isNaN(dsc)) {
                        data.push({
                            time: time,
                            temp: temp,
                            dsc: dsc,
                            heatOrCool: 'isothermal',
                            filename: filename,
                            numOfRun: 1
                        });
                    }
                }
            });
            
            return data;
        }

        // Runオフセットを適用したデータを生成
        function applyRunOffset(data, fileKey, runNumber) {
            const offsetInput = document.getElementById(`run_${fileKey}_${runNumber}_offset`);
            const offset = offsetInput ? parseFloat(offsetInput.value) || 0 : 0;
            
            return data.map(point => ({
                ...point,
                dsc: point.dsc + offset
            }));
        }

        // 範囲を自動設定
        function setAutoRanges() {
            if (Object.keys(loadedData).length === 0) return;
            
            let minTemp = Infinity, maxTemp = -Infinity;
            let minTime = Infinity, maxTime = -Infinity;
            let minDsc = Infinity, maxDsc = -Infinity;
            
            Object.values(loadedData).forEach(data => {
                data.forEach(point => {
                    minTemp = Math.min(minTemp, point.temp);
                    maxTemp = Math.max(maxTemp, point.temp);
                    minTime = Math.min(minTime, point.time);
                    maxTime = Math.max(maxTime, point.time);
                    minDsc = Math.min(minDsc, point.dsc);
                    maxDsc = Math.max(maxDsc, point.dsc);
                });
            });
            
            document.getElementById('tempMin').value = Math.floor(minTemp);
            document.getElementById('tempMax').value = Math.ceil(maxTemp);
            document.getElementById('timeMin').value = Math.floor(minTime);
            document.getElementById('timeMax').value = Math.ceil(maxTime);
            document.getElementById('dscMin').value = Math.floor(minDsc);
            document.getElementById('dscMax').value = Math.ceil(maxDsc);
        }

        // プロットを更新
        function updatePlot() {
            if (Object.keys(loadedData).length === 0) {
                showStatus('データを先に読み込んでください', 'error');
                return;
            }

            updateThermalPlot();
            updateDscPlot();
            showStatus('プロットを更新しました');
        }

        // 熱履歴プロファイルを描画（全Run同時表示）
        function updateThermalPlot() {
            const plotType = document.getElementById('plotType').value;
            const timeMin = parseFloat(document.getElementById('timeMin').value) || null;
            const timeMax = parseFloat(document.getElementById('timeMax').value) || null;
            const tempMin = parseFloat(document.getElementById('tempMin').value) || null;
            const tempMax = parseFloat(document.getElementById('tempMax').value) || null;

            const traces = [];
            const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
            let colorIndex = 0;

            // 全Runを一つのプロットに表示
            Object.keys(runData).forEach((fileKey, fileIndex) => {
                const runs = runData[fileKey];
                
                runs.forEach(run => {
                    let filteredData = run.data;
                    
                    // 時間範囲でフィルタリング
                    if (timeMin !== null || timeMax !== null) {
                        filteredData = run.data.filter(point => {
                            if (timeMin !== null && point.time < timeMin) return false;
                            if (timeMax !== null && point.time > timeMax) return false;
                            return true;
                        });
                    }

                    // 温度範囲でフィルタリング
                    if (tempMin !== null || tempMax !== null) {
                        filteredData = filteredData.filter(point => {
                            if (tempMin !== null && point.temp < tempMin) return false;
                            if (tempMax !== null && point.temp > tempMax) return false;
                            return true;
                        });
                    }

                    if (filteredData.length === 0) return;

                    const trace = {
                        x: filteredData.map(d => d.time),
                        y: filteredData.map(d => d.temp),
                        name: `File ${fileIndex + 1} Run-${run.runNumber}`,
                        line: { color: colors[colorIndex % colors.length] },
                        marker: { color: colors[colorIndex % colors.length] }
                    };
                    setTraceMode(trace, plotType);
                    traces.push(trace);
                    colorIndex++;
                });
            });

            // 凡例設定を取得
            const legendShow = document.getElementById('thermalLegendShow').checked;
            const legendPosition = document.getElementById('thermalLegendPosition').value;
            const legendConfig = getLegendConfig(legendShow, legendPosition);

            // 軸設定を取得
            const axisConfig = getAxisConfig();

            const layout = {
                title: 'Thermal Profile (All Runs)',
                xaxis: { 
                    title: axisConfig.xTitle,
                    tickfont: { size: axisConfig.labelSize, family: axisConfig.fontFamily },
                    titlefont: { size: axisConfig.fontSize, family: axisConfig.fontFamily }
                },
                yaxis: { 
                    title: axisConfig.yTitle,
                    tickfont: { size: axisConfig.labelSize, family: axisConfig.fontFamily },
                    titlefont: { size: axisConfig.fontSize, family: axisConfig.fontFamily }
                },
                font: { family: axisConfig.fontFamily, size: axisConfig.fontSize },
                legend: legendConfig,
                margin: { l: 60, r: 30, t: 40, b: 60 }
            };

            Plotly.newPlot('thermalPlot', traces, layout, {responsive: true});
        }

        // DSC曲線を描画（オフセットなしとオフセットありの2種類）
        function updateDscPlot() {
            const plotType = document.getElementById('plotType').value;
            const tempMin = parseFloat(document.getElementById('tempMin').value) || null;
            const tempMax = parseFloat(document.getElementById('tempMax').value) || null;
            const dscMin = parseFloat(document.getElementById('dscMin').value) || null;
            const dscMax = parseFloat(document.getElementById('dscMax').value) || null;

            const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
            let colorIndex = 0;

            // オフセットなしのトレース
            const tracesWithoutOffset = [];
            // オフセットありのトレース
            const tracesWithOffset = [];

            Object.keys(runData).forEach((fileKey, fileIndex) => {
                const runs = runData[fileKey];
                
                runs.forEach(run => {
                    let filteredData = run.data;
                    let offsetFilteredData = applyRunOffset(run.data, fileKey, run.runNumber);
                    
                    // 温度範囲でフィルタリング
                    if (tempMin !== null || tempMax !== null) {
                        filteredData = run.data.filter(point => {
                            if (tempMin !== null && point.temp < tempMin) return false;
                            if (tempMax !== null && point.temp > tempMax) return false;
                            return true;
                        });
                        
                        offsetFilteredData = offsetFilteredData.filter(point => {
                            if (tempMin !== null && point.temp < tempMin) return false;
                            if (tempMax !== null && point.temp > tempMax) return false;
                            return true;
                        });
                    }

                    // DSC範囲でフィルタリング（オフセットなし）
                    if (dscMin !== null || dscMax !== null) {
                        filteredData = filteredData.filter(point => {
                            if (dscMin !== null && point.dsc < dscMin) return false;
                            if (dscMax !== null && point.dsc > dscMax) return false;
                            return true;
                        });
                    }

                    if (filteredData.length === 0) return;

                    // オフセットなしのトレース
                    const traceWithoutOffset = {
                        x: filteredData.map(d => d.temp),
                        y: filteredData.map(d => d.dsc),
                        name: `File ${fileIndex + 1} Run-${run.runNumber} (No Offset)`,
                        line: { color: colors[colorIndex % colors.length] },
                        marker: { color: colors[colorIndex % colors.length] },
                        xaxis: 'x1',
                        yaxis: 'y1'
                    };
                    setTraceMode(traceWithoutOffset, plotType);
                    tracesWithoutOffset.push(traceWithoutOffset);

                    // オフセットありのトレース
                    const traceWithOffset = {
                        x: offsetFilteredData.map(d => d.temp),
                        y: offsetFilteredData.map(d => d.dsc),
                        name: `File ${fileIndex + 1} Run-${run.runNumber} (With Offset)`,
                        line: { color: colors[colorIndex % colors.length] },
                        marker: { color: colors[colorIndex % colors.length] },
                        xaxis: 'x2',
                        yaxis: 'y2'
                    };
                    setTraceMode(traceWithOffset, plotType);
                    tracesWithOffset.push(traceWithOffset);

                    colorIndex++;
                });
            });

            // 2つのサブプロットを作成
            const traces = [...tracesWithoutOffset, ...tracesWithOffset];

            // 凡例設定を取得
            const legendShow = document.getElementById('dscLegendShow').checked;
            const legendPosition = document.getElementById('dscLegendPosition').value;
            const legendConfig = getLegendConfig(legendShow, legendPosition);

            // 軸設定を取得
            const axisConfig = getAxisConfig();

            const layout = {
                title: 'DSC Curve Comparison',
                font: { family: axisConfig.fontFamily, size: axisConfig.fontSize },
                grid: {
                    rows: 2,
                    columns: 1,
                    pattern: 'independent'
                },
                xaxis: {
                    title: axisConfig.xTitle,
                    tickfont: { size: axisConfig.labelSize, family: axisConfig.fontFamily },
                    titlefont: { size: axisConfig.fontSize, family: axisConfig.fontFamily },
                    domain: [0, 1]
                },
                yaxis: {
                    title: axisConfig.dscYTitle + ' - No Offset',
                    tickfont: { size: axisConfig.labelSize, family: axisConfig.fontFamily },
                    titlefont: { size: axisConfig.fontSize, family: axisConfig.fontFamily },
                    domain: [0.55, 1]
                },
                xaxis2: {
                    title: axisConfig.xTitle,
                    tickfont: { size: axisConfig.labelSize, family: axisConfig.fontFamily },
                    titlefont: { size: axisConfig.fontSize, family: axisConfig.fontFamily },
                    domain: [0, 1]
                },
                yaxis2: {
                    title: axisConfig.dscYTitle + ' - With Offset',
                    tickfont: { size: axisConfig.labelSize, family: axisConfig.fontFamily },
                    titlefont: { size: axisConfig.fontSize, family: axisConfig.fontFamily },
                    domain: [0, 0.45]
                },
                legend: legendConfig,
                margin: { l: 60, r: 30, t: 60, b: 60 },
                height: 800
            };

            Plotly.newPlot('dscPlot', traces, layout, {responsive: true});
        }

        // Run情報タブ用の熱履歴プロファイルを描画
        function updateRunThermalPlot() {
            if (Object.keys(loadedData).length === 0) {
                return;
            }

            const traces = [];
            const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
            let colorIndex = 0;

            // 全Runを一つのプロットに表示
            Object.keys(runData).forEach((fileKey, fileIndex) => {
                const runs = runData[fileKey];
                
                runs.forEach(run => {
                    const trace = {
                        x: run.data.map(d => d.time),
                        y: run.data.map(d => d.temp),
                        name: `File ${fileIndex + 1} Run-${run.runNumber}`,
                        line: { color: colors[colorIndex % colors.length], width: 2 },
                        marker: { color: colors[colorIndex % colors.length], size: 4 },
                        mode: 'lines+markers',
                        type: 'scatter'
                    };
                    traces.push(trace);
                    colorIndex++;
                });
            });

            const layout = {
                title: 'Thermal Profile - Run Information View',
                xaxis: { 
                    title: 'Time (sec)',
                    tickfont: { size: 12 },
                    titlefont: { size: 14 }
                },
                yaxis: { 
                    title: 'Temperature (K)',
                    tickfont: { size: 12 },
                    titlefont: { size: 14 }
                },
                font: { family: 'Times New Roman', size: 12 },
                legend: {
                    x: 0.02,
                    y: 0.98,
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: 'rgba(0,0,0,0.2)',
                    borderwidth: 1
                },
                margin: { l: 60, r: 30, t: 40, b: 60 },
                height: 400
            };

            Plotly.newPlot('runThermalPlot', traces, layout, {responsive: true});
        }

        // Run設定を保存（データファイルと同じディレクトリに）
        function saveRunSettings() {
            if (Object.keys(runData).length === 0) {
                showStatus('保存するRun設定がありません', 'error');
                return;
            }

            const settings = {
                filenames: currentFilenames,
                runData: runData,
                timestamp: new Date().toISOString(),
                version: '1.0'
            };

            try {
                // データファイルと同じディレクトリに保存するため、最初のファイル名からディレクトリを取得
                const firstFileName = currentFilenames[0];
                if (!firstFileName) {
                    showStatus('ファイル名が取得できません', 'error');
                    return;
                }

                // ファイル名からディレクトリパスを取得（実際のファイルシステムでは使用できないため、ファイル名ベースで生成）
                const baseFileName = firstFileName.replace(/\.[^/.]+$/, ""); // 拡張子を除去
                const settingsFileName = `${baseFileName}_run_settings.json`;
                
                // Blobを作成してダウンロード
                const blob = new Blob([JSON.stringify(settings, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = settingsFileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showStatus(`Run設定を ${settingsFileName} として保存しました`, 'success');
            } catch (error) {
                console.error('Error saving run settings:', error);
                showStatus('Run設定の保存に失敗しました', 'error');
            }
        }

        // Run設定を読み込み（ファイルから）
        function loadRunSettings() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const settings = JSON.parse(e.target.result);
                        
                        // ファイル名が一致するかチェック
                        if (settings.filenames && settings.filenames.length === currentFilenames.length) {
                            const filenamesMatch = settings.filenames.every((name, index) => 
                                name === currentFilenames[index]
                            );
                            
                            if (filenamesMatch && settings.runData) {
                                runData = settings.runData;
                                generateRunTimeInputs();
                                displayRunInfo();
                                updateRunThermalPlot();
                                showStatus('Run設定を読み込みました', 'success');
                            } else {
                                showStatus('ファイル名が一致しません', 'error');
                            }
                        } else {
                            showStatus('ファイル数が一致しません', 'error');
                        }
                    } catch (error) {
                        console.error('Error parsing run settings file:', error);
                        showStatus('Run設定ファイルの解析に失敗しました', 'error');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // Run設定をエクスポート
        function exportRunSettings() {
            if (Object.keys(runData).length === 0) {
                showStatus('エクスポートするRun設定がありません', 'error');
                return;
            }

            const settings = {
                filenames: currentFilenames,
                runData: runData,
                timestamp: new Date().toISOString(),
                version: '1.0'
            };

            try {
                // データファイルと同じディレクトリに保存するため、最初のファイル名からディレクトリを取得
                const firstFileName = currentFilenames[0];
                if (!firstFileName) {
                    showStatus('ファイル名が取得できません', 'error');
                    return;
                }

                // ファイル名からディレクトリパスを取得（実際のファイルシステムでは使用できないため、ファイル名ベースで生成）
                const baseFileName = firstFileName.replace(/\.[^/.]+$/, ""); // 拡張子を除去
                const settingsFileName = `${baseFileName}_run_settings_${new Date().toISOString().split('T')[0]}.json`;
                
                const dataStr = JSON.stringify(settings, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = settingsFileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showStatus(`Run設定を ${settingsFileName} としてエクスポートしました`, 'success');
            } catch (error) {
                console.error('Failed to export run settings:', error);
                showStatus('Run設定のエクスポートに失敗しました', 'error');
            }
        }

        // Run設定をインポート
        function importRunSettings() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const settings = JSON.parse(e.target.result);
                        
                        // バージョンチェック
                        if (!settings.version) {
                            showStatus('古い形式の設定ファイルです', 'error');
                            return;
                        }

                        // ファイル名が一致するかチェック
                        if (settings.filenames && settings.filenames.length === currentFilenames.length) {
                            const filenamesMatch = settings.filenames.every((name, index) => 
                                name === currentFilenames[index]
                            );
                            
                            if (filenamesMatch && settings.runData) {
                                runData = settings.runData;
                                generateRunTimeInputs();
                                displayRunInfo();
                                updateRunThermalPlot();
                                showStatus('Run設定をインポートしました');
                                return;
                            }
                        }
                        
                        showStatus('ファイル名が一致しません。同じファイルを読み込んでからインポートしてください', 'error');
                    } catch (error) {
                        console.error('Failed to import run settings:', error);
                        showStatus('Run設定のインポートに失敗しました', 'error');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // 凡例設定を取得する関数
        function getLegendConfig(show, position) {
            if (!show) {
                return { visible: false };
            }

            const positionMap = {
                'top-left': { x: 0.02, y: 0.98, xanchor: 'left', yanchor: 'top' },
                'top-right': { x: 0.98, y: 0.98, xanchor: 'right', yanchor: 'top' },
                'bottom-left': { x: 0.02, y: 0.02, xanchor: 'left', yanchor: 'bottom' },
                'bottom-right': { x: 0.98, y: 0.02, xanchor: 'right', yanchor: 'bottom' },
                'top-center': { x: 0.5, y: 0.98, xanchor: 'center', yanchor: 'top' },
                'bottom-center': { x: 0.5, y: 0.02, xanchor: 'center', yanchor: 'bottom' }
            };

            const pos = positionMap[position] || positionMap['top-left'];

            return {
                visible: true,
                x: pos.x,
                y: pos.y,
                xanchor: pos.xanchor,
                yanchor: pos.yanchor,
                bgcolor: 'rgba(255,255,255,0.8)',
                bordercolor: 'rgba(0,0,0,0.2)',
                borderwidth: 1
            };
        }

        // 軸設定を取得する関数
        function getAxisConfig() {
            return {
                xTitle: document.getElementById('xAxisTitle').value || 'Time (sec)',
                yTitle: document.getElementById('yAxisTitle').value || 'Temperature (K)',
                dscYTitle: document.getElementById('dscYAxisTitle').value || 'DSC (uW)',
                fontFamily: document.getElementById('fontFamily').value || 'Times New Roman',
                fontSize: parseInt(document.getElementById('fontSize').value) || 14,
                labelSize: parseInt(document.getElementById('axisLabelSize').value) || 12
            };
        }

        // トレースのモードを設定
        function setTraceMode(trace, plotType) {
            if (plotType === 'scatter') {
                trace.mode = 'markers';
                trace.type = 'scatter';
            } else if (plotType === 'line') {
                trace.mode = 'lines';
                trace.type = 'scatter';
            } else { // both
                trace.mode = 'lines+markers';
                trace.type = 'scatter';
            }
        }

        // プロットをリセット
        function resetPlot() {
            document.getElementById('tempMin').value = '';
            document.getElementById('tempMax').value = '';
            document.getElementById('timeMin').value = '';
            document.getElementById('timeMax').value = '';
            document.getElementById('dscMin').value = '';
            document.getElementById('dscMax').value = '';
            setAutoRanges();
            updatePlot();
        }

        // データ表示関数
        function displayData() {
            const dataDisplay = document.getElementById('dataDisplay');
            const dataTable = document.getElementById('dataTable');
            
            let html = '<table class="data-table">';
            html += '<thead><tr><th>ファイル</th><th>データ点数</th><th>時間範囲</th><th>温度範囲</th><th>DSC範囲</th></tr></thead>';
            html += '<tbody>';
            
            Object.keys(loadedData).forEach(key => {
                const data = loadedData[key];
                const timeRange = `${data[0].time.toFixed(1)} - ${data[data.length-1].time.toFixed(1)}`;
                const tempRange = `${data[0].temp.toFixed(1)} - ${data[data.length-1].temp.toFixed(1)}`;
                const dscValues = data.map(d => d.dsc);
                const dscRange = `${Math.min(...dscValues).toFixed(1)} - ${Math.max(...dscValues).toFixed(1)}`;
                
                html += `<tr>
                    <td>File ${parseInt(key)+1}</td>
                    <td>${data.length}</td>
                    <td>${timeRange}</td>
                    <td>${tempRange}</td>
                    <td>${dscRange}</td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            dataTable.innerHTML = html;
            dataDisplay.style.display = 'block';
        }

        // ページ読み込み時の初期化
        document.addEventListener('DOMContentLoaded', function() {
            showStatus('DSCデータローダーが準備できました');
        });
    </script>
</body>
</html>
